# MiniLang Interpreter (C++)

Интерпретатор небольшого учебного языка на C++.  
Программа читает исходный код **построчно из stdin**, делает лексический разбор, переводит выражения в **постфиксную запись (RPN)** и выполняет, поддерживая переменные, метки/переходы и базовые управляющие конструкции.

---

## Содержание

- [Возможности](#возможности)
- [Быстрый старт](#быстрый-старт)
- [Синтаксис языка](#синтаксис-языка)
  - [Числа и переменные](#числа-и-переменные)
  - [Присваивание](#присваивание)
  - [Скобки](#скобки)
  - [Операции](#операции)
  - [Вывод](#вывод)
  - [Условия `if/else`](#условия-ifelse)
  - [Циклы `while`](#циклы-while)
  - [Метки и `goto`](#метки-и-goto)
- [Примеры программ](#примеры-программ)
- [Как устроен интерпретатор](#как-устроен-интерпретатор)
- [Структура кода](#структура-кода)
- [Известные моменты и идеи улучшений](#известные-моменты-и-идеи-улучшений)
- [Лицензия](#лицензия)

---

## Возможности

- **Целые числа**
- **Переменные** (имена из букв: `a`, `sum`, `value`)
- **Присваивание**: `:=`
- **Скобки**: `(` `)`
- **Операции**:
  - логические: `and`, `or`
  - битовые: `&`, `|`, `^`, `<<`, `>>`
  - сравнения: `==`, `!=`, `<`, `<=`, `>`, `>=`
  - арифметика: `+`, `-`, `*`, `/`, `%` *(см. “Известные моменты”)*
- **Управляющие конструкции**:
  - `if ... then ... else ... endif`
  - `while ... endwhile`
- **Метки и переходы**:
  - метка: `label:`
  - переход: `goto label`

---

## Быстрый старт

### Сборка

```bash
g++ -std=c++17 -O2 -o minilang main.cpp
````

### Запуск

```bash
./minilang
```

Вводи программу строка за строкой. Для выхода напиши:

* `exit`
* `quit`

> Примечание: в текущей версии перед выполнением печатается **постфиксная форма** каждой строки (`print(postfix)` в `main`). Это удобно для отладки.

---

## Синтаксис языка

### Числа и переменные

```text
x := 10
y := x
```

Имена переменных состоят только из букв (`isalpha`). Цифры и `_` в имени сейчас не поддерживаются.

---

### Присваивание

Оператор присваивания — `:=`.

```text
a := 5
b := a + 10
```

---

### Скобки

```text
a := (2 + 3) * 4
```

---

### Операции

Поддерживаются:

* Арифметика: `+  -  *  /  %`
* Сравнения: `==  !=  <  <=  >  >=`
* Логика: `and  or`
* Битовые: `&  |  ^  <<  >>`

Пример:

```text
a := 6
b := 3
a & b
a | b
a ^ b
a << 1
a >= b
```

---

### Вывод

Интерпретатор печатает результат строки, если строка **не является присваиванием**.

```text
a := 2
a + 3
```

Вывод:

```text
5
```

---

### Условия `if/else`

Форма:

```text
if <условие> then
    <строки>
else
    <строки>
endif
```

Пример:

```text
a := 5
if a > 3 then
  100
else
  200
endif
```

---

### Циклы `while`

Форма:

```text
while <условие>
    <строки>
endwhile
```

Пример:

```text
a := 0
while a < 3
  a := a + 1
  a
endwhile
```

---

### Метки и `goto`

Метка:

```text
start:
```

Переход:

```text
goto start
```

Пример:

```text
start:
a := 1
goto start
```

---

## Примеры программ

### 1) Арифметика

```text
a := 10
b := 7
a + b
a * b
quit
```

Ожидаемый вывод:

```text
17
70
```

---

### 2) Условие

```text
a := 2
if a == 2 then
  111
else
  999
endif
quit
```

Вывод:

```text
111
```

---

### 3) Цикл

```text
a := 0
while a < 5
  a := a + 1
  a
endwhile
quit
```

Вывод:

```text
1
2
3
4
5
```

---

## Как устроен интерпретатор

Выполнение программы состоит из этапов:

1. **Лексический разбор**
   Каждая строка превращается в список лексем: `Number`, `Variable`, `Oper`, `Goto`.

2. **Таблица меток**
   Конструкции вида `label:` заносятся в `lables[name] = row`.
   Лексемы метки удаляются из строки (заменяются на `nullptr`), чтобы не мешать вычислению.

3. **Связывание переходов (jump-адреса)**
   Для `if/else/endif` и `while/endwhile` вычисляются строки, куда нужно прыгать.

4. **Преобразование инфикс → постфикс (RPN)**
   Используется стек операторов и массив приоритетов `PRIORITY`.

5. **Вычисление постфикса**
   Значения считаются стеком:

   * бинарные операции берут два операнда со стека;
   * `:=` меняет значение переменной;
   * `goto/else/endwhile` возвращают новый номер строки;
   * `if/while` проверяют условие и прыгают, если оно ложное.

---

## Структура кода

Классы:

* `Lexem` — базовый класс лексем
* `Number` — целое число
* `Variable` — переменная (значения лежат в `VarTable`)
* `Oper` — оператор (тип + приоритет + текст)
* `Goto` — оператор с полем `row` (куда прыгать)

Основные функции:

* `parseLexem()` — лексинг строки
* `initLables()` — сбор таблицы меток
* `initJumps()` — связывание `if/else/endif` и `while/endwhile`
* `buildPostfix()` — инфикс → постфикс (RPN)
* `evaluatePostfix()` — выполнение постфикса
* `calc()` — вычисление операций и присваивания

---

## Известные моменты и идеи улучшений

* Оператор `/` объявлен в `enum`, но в `calc()` **нет ветки `DIV`** (деление сейчас фактически не реализовано).
* Проверка меток сделана через `if (lexemvar->inLabelTable())`.
  Если метка указывает на строку `0`, условие будет ложным (вернётся `0`). Надёжнее использовать `lables.count(name)`.
* Память: лексемы создаются через `new`, есть функция `delet()`, но она не вызывается в конце `main`.
* Можно добавить обработку ошибок: неизвестные токены, деление на ноль, пустой стек, незакрытые блоки `if/while`.
* Можно добавить режим запуска “без печати RPN” (сейчас `print(postfix)` всегда выводит постфикс для отладки).

---
- или оформить README в стиле “лабораторная работа” (цель, алгоритмы, тесты, вывод).
```
